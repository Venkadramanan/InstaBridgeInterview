/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**!
 * Sortable
 * @author	RubaXa   <trash@rubaxa.org>
 * @license MIT
 */

(function (factory) {
  "use strict";

  if (typeof define === "function" && define.amd) {
    define(factory);
  } else if (typeof module != "undefined" && typeof module.exports != "undefined") {
    module.exports = factory();
  } else if (typeof Package !== "undefined") {
    Sortable = factory(); // export for Meteor.js
  } else {
    /* jshint sub:true */
    window["Sortable"] = factory();
  }
})(function () {
  "use strict";

  if (typeof window == "undefined" || typeof window.document == "undefined") {
    return function () {
      throw new Error("Sortable.js requires a window with a document");
    };
  }
  var dragEl,
    parentEl,
    ghostEl,
    cloneEl,
    rootEl,
    nextEl,
    scrollEl,
    scrollParentEl,
    lastEl,
    lastCSS,
    lastParentCSS,
    oldIndex,
    newIndex,
    activeGroup,
    autoScroll = {},
    tapEvt,
    touchEvt,
    moved,
    /** @const */
    RSPACE = /\s+/g,
    expando = 'Sortable' + new Date().getTime(),
    win = window,
    document = win.document,
    parseInt = win.parseInt,
    supportDraggable = !!('draggable' in document.createElement('div')),
    supportCssPointerEvents = function (el) {
      el = document.createElement('x');
      el.style.cssText = 'pointer-events:auto';
      return el.style.pointerEvents === 'auto';
    }(),
    _silent = false,
    abs = Math.abs,
    slice = [].slice,
    touchDragOverListeners = [],
    _autoScroll = _throttle(function ( /**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl) {
      // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
      if (rootEl && options.scroll) {
        var el,
          rect,
          sens = options.scrollSensitivity,
          speed = options.scrollSpeed,
          x = evt.clientX,
          y = evt.clientY,
          winWidth = window.innerWidth,
          winHeight = window.innerHeight,
          vx,
          vy;

        // Delect scrollEl
        if (scrollParentEl !== rootEl) {
          scrollEl = options.scroll;
          scrollParentEl = rootEl;
          if (scrollEl === true) {
            scrollEl = rootEl;
            do {
              if (scrollEl.offsetWidth < scrollEl.scrollWidth || scrollEl.offsetHeight < scrollEl.scrollHeight) {
                break;
              }
              /* jshint boss:true */
            } while (scrollEl = scrollEl.parentNode);
          }
        }
        if (scrollEl) {
          el = scrollEl;
          rect = scrollEl.getBoundingClientRect();
          vx = (abs(rect.right - x) <= sens) - (abs(rect.left - x) <= sens);
          vy = (abs(rect.bottom - y) <= sens) - (abs(rect.top - y) <= sens);
        }
        if (!(vx || vy)) {
          vx = (winWidth - x <= sens) - (x <= sens);
          vy = (winHeight - y <= sens) - (y <= sens);

          /* jshint expr:true */
          (vx || vy) && (el = win);
        }
        if (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {
          autoScroll.el = el;
          autoScroll.vx = vx;
          autoScroll.vy = vy;
          clearInterval(autoScroll.pid);
          if (el) {
            autoScroll.pid = setInterval(function () {
              if (el === win) {
                win.scrollTo(win.pageXOffset + vx * speed, win.pageYOffset + vy * speed);
              } else {
                vy && (el.scrollTop += vy * speed);
                vx && (el.scrollLeft += vx * speed);
              }
            }, 24);
          }
        }
      }
    }, 30),
    _prepareGroup = function _prepareGroup(options) {
      var group = options.group;
      if (!group || _typeof(group) != 'object') {
        group = options.group = {
          name: group
        };
      }
      ['pull', 'put'].forEach(function (key) {
        if (!(key in group)) {
          group[key] = true;
        }
      });
      options.groups = ' ' + group.name + (group.put.join ? ' ' + group.put.join(' ') : '') + ' ';
    };

  /**
   * @class  Sortable
   * @param  {HTMLElement}  el
   * @param  {Object}       [options]
   */
  function Sortable(el, options) {
    if (!(el && el.nodeType && el.nodeType === 1)) {
      throw 'Sortable: `el` must be HTMLElement, and not ' + {}.toString.call(el);
    }
    this.el = el; // root element
    this.options = options = _extend({}, options);

    // Export instance
    el[expando] = this;

    // Default options
    var defaults = {
      group: Math.random(),
      sort: true,
      disabled: false,
      store: null,
      handle: null,
      scroll: true,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      draggable: /[uo]l/i.test(el.nodeName) ? 'li' : '>*',
      ghostClass: 'sortable-ghost',
      chosenClass: 'sortable-chosen',
      ignore: 'a, img',
      filter: null,
      animation: 0,
      setData: function setData(dataTransfer, dragEl) {
        dataTransfer.setData('Text', dragEl.textContent);
      },
      dropBubble: false,
      dragoverBubble: false,
      dataIdAttr: 'data-id',
      delay: 0,
      forceFallback: false,
      fallbackClass: 'sortable-fallback',
      fallbackOnBody: false
    };

    // Set default options
    for (var name in defaults) {
      !(name in options) && (options[name] = defaults[name]);
    }
    _prepareGroup(options);

    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_') {
        this[fn] = this[fn].bind(this);
      }
    }

    // Setup drag mode
    this.nativeDraggable = options.forceFallback ? false : supportDraggable;

    // Bind events
    _on(el, 'mousedown', this._onTapStart);
    _on(el, 'touchstart', this._onTapStart);
    if (this.nativeDraggable) {
      _on(el, 'dragover', this);
      _on(el, 'dragenter', this);
    }
    touchDragOverListeners.push(this._onDragOver);

    // Restore sorting
    options.store && this.sort(options.store.get(this));
  }
  Sortable.prototype = /** @lends Sortable.prototype */{
    constructor: Sortable,
    _onTapStart: function _onTapStart( /** Event|TouchEvent */evt) {
      var _this = this,
        el = this.el,
        options = this.options,
        type = evt.type,
        touch = evt.touches && evt.touches[0],
        target = (touch || evt).target,
        originalTarget = target,
        filter = options.filter;
      if (type === 'mousedown' && evt.button !== 0 || options.disabled) {
        return; // only left button or enabled
      }

      target = _closest(target, options.draggable, el);
      if (!target) {
        return;
      }

      // get the index of the dragged element within its parent
      oldIndex = _index(target, options.draggable);

      // Check filter
      if (typeof filter === 'function') {
        if (filter.call(this, evt, target, this)) {
          _dispatchEvent(_this, originalTarget, 'filter', target, el, oldIndex);
          evt.preventDefault();
          return; // cancel dnd
        }
      } else if (filter) {
        filter = filter.split(',').some(function (criteria) {
          criteria = _closest(originalTarget, criteria.trim(), el);
          if (criteria) {
            _dispatchEvent(_this, criteria, 'filter', target, el, oldIndex);
            return true;
          }
        });
        if (filter) {
          evt.preventDefault();
          return; // cancel dnd
        }
      }

      if (options.handle && !_closest(originalTarget, options.handle, el)) {
        return;
      }

      // Prepare `dragstart`
      this._prepareDragStart(evt, touch, target);
    },
    _prepareDragStart: function _prepareDragStart( /** Event */evt, /** Touch */touch, /** HTMLElement */target) {
      var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;
      if (target && !dragEl && target.parentNode === el) {
        tapEvt = evt;
        rootEl = el;
        dragEl = target;
        parentEl = dragEl.parentNode;
        nextEl = dragEl.nextSibling;
        activeGroup = options.group;
        dragStartFn = function dragStartFn() {
          // Delayed drag has been triggered
          // we can re-enable the events: touchmove/mousemove
          _this._disableDelayedDrag();

          // Make the element draggable
          dragEl.draggable = true;

          // Chosen item
          _toggleClass(dragEl, _this.options.chosenClass, true);

          // Bind the events: dragstart/dragend
          _this._triggerDragStart(touch);
        };

        // Disable "draggable"
        options.ignore.split(',').forEach(function (criteria) {
          _find(dragEl, criteria.trim(), _disableDraggable);
        });
        _on(ownerDocument, 'mouseup', _this._onDrop);
        _on(ownerDocument, 'touchend', _this._onDrop);
        _on(ownerDocument, 'touchcancel', _this._onDrop);
        if (options.delay) {
          // If the user moves the pointer or let go the click or touch
          // before the delay has been reached:
          // disable the delayed drag
          _on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
          _on(ownerDocument, 'touchend', _this._disableDelayedDrag);
          _on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
          _on(ownerDocument, 'mousemove', _this._disableDelayedDrag);
          _on(ownerDocument, 'touchmove', _this._disableDelayedDrag);
          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
        } else {
          dragStartFn();
        }
      }
    },
    _disableDelayedDrag: function _disableDelayedDrag() {
      var ownerDocument = this.el.ownerDocument;
      clearTimeout(this._dragStartTimer);
      _off(ownerDocument, 'mouseup', this._disableDelayedDrag);
      _off(ownerDocument, 'touchend', this._disableDelayedDrag);
      _off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
      _off(ownerDocument, 'mousemove', this._disableDelayedDrag);
      _off(ownerDocument, 'touchmove', this._disableDelayedDrag);
    },
    _triggerDragStart: function _triggerDragStart( /** Touch */touch) {
      if (touch) {
        // Touch device support
        tapEvt = {
          target: dragEl,
          clientX: touch.clientX,
          clientY: touch.clientY
        };
        this._onDragStart(tapEvt, 'touch');
      } else if (!this.nativeDraggable) {
        this._onDragStart(tapEvt, true);
      } else {
        _on(dragEl, 'dragend', this);
        _on(rootEl, 'dragstart', this._onDragStart);
      }
      try {
        if (document.selection) {
          // Timeout neccessary for IE9					
          setTimeout(function () {
            document.selection.empty();
          });
        } else {
          window.getSelection().removeAllRanges();
        }
      } catch (err) {}
    },
    _dragStarted: function _dragStarted() {
      if (rootEl && dragEl) {
        // Apply effect
        _toggleClass(dragEl, this.options.ghostClass, true);
        Sortable.active = this;

        // Drag start event
        _dispatchEvent(this, rootEl, 'start', dragEl, rootEl, oldIndex);
      }
    },
    _emulateDragOver: function _emulateDragOver() {
      if (touchEvt) {
        if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY) {
          return;
        }
        this._lastX = touchEvt.clientX;
        this._lastY = touchEvt.clientY;
        if (!supportCssPointerEvents) {
          _css(ghostEl, 'display', 'none');
        }
        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY),
          parent = target,
          groupName = ' ' + this.options.group.name + '',
          i = touchDragOverListeners.length;
        if (parent) {
          do {
            if (parent[expando] && parent[expando].options.groups.indexOf(groupName) > -1) {
              while (i--) {
                touchDragOverListeners[i]({
                  clientX: touchEvt.clientX,
                  clientY: touchEvt.clientY,
                  target: target,
                  rootEl: parent
                });
              }
              break;
            }
            target = parent; // store last element
          }
          /* jshint boss:true */ while (parent = parent.parentNode);
        }
        if (!supportCssPointerEvents) {
          _css(ghostEl, 'display', '');
        }
      }
    },
    _onTouchMove: function _onTouchMove( /**TouchEvent*/evt) {
      if (tapEvt) {
        // only set the status to dragging, when we are actually dragging
        if (!Sortable.active) {
          this._dragStarted();
        }

        // as well as creating the ghost element on the document body
        this._appendGhost();
        var touch = evt.touches ? evt.touches[0] : evt,
          dx = touch.clientX - tapEvt.clientX,
          dy = touch.clientY - tapEvt.clientY,
          translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';
        moved = true;
        touchEvt = touch;
        _css(ghostEl, 'webkitTransform', translate3d);
        _css(ghostEl, 'mozTransform', translate3d);
        _css(ghostEl, 'msTransform', translate3d);
        _css(ghostEl, 'transform', translate3d);
        evt.preventDefault();
      }
    },
    _appendGhost: function _appendGhost() {
      if (!ghostEl) {
        var rect = dragEl.getBoundingClientRect(),
          css = _css(dragEl),
          options = this.options,
          ghostRect;
        ghostEl = dragEl.cloneNode(true);
        _toggleClass(ghostEl, options.ghostClass, false);
        _toggleClass(ghostEl, options.fallbackClass, true);
        _css(ghostEl, 'top', rect.top - parseInt(css.marginTop, 10));
        _css(ghostEl, 'left', rect.left - parseInt(css.marginLeft, 10));
        _css(ghostEl, 'width', rect.width);
        _css(ghostEl, 'height', rect.height);
        _css(ghostEl, 'opacity', '0.8');
        _css(ghostEl, 'position', 'fixed');
        _css(ghostEl, 'zIndex', '100000');
        _css(ghostEl, 'pointerEvents', 'none');
        options.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);

        // Fixing dimensions.
        ghostRect = ghostEl.getBoundingClientRect();
        _css(ghostEl, 'width', rect.width * 2 - ghostRect.width);
        _css(ghostEl, 'height', rect.height * 2 - ghostRect.height);
      }
    },
    _onDragStart: function _onDragStart( /**Event*/evt, /**boolean*/useFallback) {
      var dataTransfer = evt.dataTransfer,
        options = this.options;
      this._offUpEvents();
      if (activeGroup.pull == 'clone') {
        cloneEl = dragEl.cloneNode(true);
        _css(cloneEl, 'display', 'none');
        rootEl.insertBefore(cloneEl, dragEl);
      }
      if (useFallback) {
        if (useFallback === 'touch') {
          // Bind touch events
          _on(document, 'touchmove', this._onTouchMove);
          _on(document, 'touchend', this._onDrop);
          _on(document, 'touchcancel', this._onDrop);
        } else {
          // Old brwoser
          _on(document, 'mousemove', this._onTouchMove);
          _on(document, 'mouseup', this._onDrop);
        }
        this._loopId = setInterval(this._emulateDragOver, 50);
      } else {
        if (dataTransfer) {
          dataTransfer.effectAllowed = 'move';
          options.setData && options.setData.call(this, dataTransfer, dragEl);
        }
        _on(document, 'drop', this);
        setTimeout(this._dragStarted, 0);
      }
    },
    _onDragOver: function _onDragOver( /**Event*/evt) {
      var el = this.el,
        target,
        dragRect,
        revert,
        options = this.options,
        group = options.group,
        groupPut = group.put,
        isOwner = activeGroup === group,
        canSort = options.sort;
      if (evt.preventDefault !== void 0) {
        evt.preventDefault();
        !options.dragoverBubble && evt.stopPropagation();
      }
      moved = true;
      if (activeGroup && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
      : activeGroup.pull && groupPut && (activeGroup.name === group.name ||
      // by Name
      groupPut.indexOf && ~groupPut.indexOf(activeGroup.name) // by Array
      )) && (evt.rootEl === void 0 || evt.rootEl === this.el) // touch fallback
      ) {
        // Smart auto-scrolling
        _autoScroll(evt, options, this.el);
        if (_silent) {
          return;
        }
        target = _closest(evt.target, options.draggable, el);
        dragRect = dragEl.getBoundingClientRect();
        if (revert) {
          _cloneHide(true);
          if (cloneEl || nextEl) {
            rootEl.insertBefore(dragEl, cloneEl || nextEl);
          } else if (!canSort) {
            rootEl.appendChild(dragEl);
          }
          return;
        }
        if (el.children.length === 0 || el.children[0] === ghostEl || el === evt.target && (target = _ghostIsLast(el, evt))) {
          if (target) {
            if (target.animated) {
              return;
            }
            targetRect = target.getBoundingClientRect();
          }
          _cloneHide(isOwner);
          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect) !== false) {
            if (!dragEl.contains(el)) {
              el.appendChild(dragEl);
              parentEl = el; // actualization
            }

            this._animate(dragRect, dragEl);
            target && this._animate(targetRect, target);
          }
        } else if (target && !target.animated && target !== dragEl && target.parentNode[expando] !== void 0) {
          if (lastEl !== target) {
            lastEl = target;
            lastCSS = _css(target);
            lastParentCSS = _css(target.parentNode);
          }
          var targetRect = target.getBoundingClientRect(),
            width = targetRect.right - targetRect.left,
            height = targetRect.bottom - targetRect.top,
            floating = /left|right|inline/.test(lastCSS.cssFloat + lastCSS.display) || lastParentCSS.display == 'flex' && lastParentCSS['flex-direction'].indexOf('row') === 0,
            isWide = target.offsetWidth > dragEl.offsetWidth,
            isLong = target.offsetHeight > dragEl.offsetHeight,
            halfway = (floating ? (evt.clientX - targetRect.left) / width : (evt.clientY - targetRect.top) / height) > 0.5,
            nextSibling = target.nextElementSibling,
            moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect),
            after;
          if (moveVector !== false) {
            _silent = true;
            setTimeout(_unsilent, 30);
            _cloneHide(isOwner);
            if (moveVector === 1 || moveVector === -1) {
              after = moveVector === 1;
            } else if (floating) {
              var elTop = dragEl.offsetTop,
                tgTop = target.offsetTop;
              if (elTop === tgTop) {
                after = target.previousElementSibling === dragEl && !isWide || halfway && isWide;
              } else {
                after = tgTop > elTop;
              }
            } else {
              after = nextSibling !== dragEl && !isLong || halfway && isLong;
            }
            if (!dragEl.contains(el)) {
              if (after && !nextSibling) {
                el.appendChild(dragEl);
              } else {
                target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
              }
            }
            parentEl = dragEl.parentNode; // actualization

            this._animate(dragRect, dragEl);
            this._animate(targetRect, target);
          }
        }
      }
    },
    _animate: function _animate(prevRect, target) {
      var ms = this.options.animation;
      if (ms) {
        var currentRect = target.getBoundingClientRect();
        _css(target, 'transition', 'none');
        _css(target, 'transform', 'translate3d(' + (prevRect.left - currentRect.left) + 'px,' + (prevRect.top - currentRect.top) + 'px,0)');
        target.offsetWidth; // repaint

        _css(target, 'transition', 'all ' + ms + 'ms');
        _css(target, 'transform', 'translate3d(0,0,0)');
        clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          _css(target, 'transition', '');
          _css(target, 'transform', '');
          target.animated = false;
        }, ms);
      }
    },
    _offUpEvents: function _offUpEvents() {
      var ownerDocument = this.el.ownerDocument;
      _off(document, 'touchmove', this._onTouchMove);
      _off(ownerDocument, 'mouseup', this._onDrop);
      _off(ownerDocument, 'touchend', this._onDrop);
      _off(ownerDocument, 'touchcancel', this._onDrop);
    },
    _onDrop: function _onDrop( /**Event*/evt) {
      var el = this.el,
        options = this.options;
      clearInterval(this._loopId);
      clearInterval(autoScroll.pid);
      clearTimeout(this._dragStartTimer);

      // Unbind events
      _off(document, 'mousemove', this._onTouchMove);
      if (this.nativeDraggable) {
        _off(document, 'drop', this);
        _off(el, 'dragstart', this._onDragStart);
      }
      this._offUpEvents();
      if (evt) {
        if (moved) {
          evt.preventDefault();
          !options.dropBubble && evt.stopPropagation();
        }
        ghostEl && ghostEl.parentNode.removeChild(ghostEl);
        if (dragEl) {
          if (this.nativeDraggable) {
            _off(dragEl, 'dragend', this);
          }
          _disableDraggable(dragEl);

          // Remove class's
          _toggleClass(dragEl, this.options.ghostClass, false);
          _toggleClass(dragEl, this.options.chosenClass, false);
          if (rootEl !== parentEl) {
            newIndex = _index(dragEl, options.draggable);
            if (newIndex >= 0) {
              // drag from one list and drop into another
              _dispatchEvent(null, parentEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
              _dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);

              // Add event
              _dispatchEvent(null, parentEl, 'add', dragEl, rootEl, oldIndex, newIndex);

              // Remove event
              _dispatchEvent(this, rootEl, 'remove', dragEl, rootEl, oldIndex, newIndex);
            }
          } else {
            // Remove clone
            cloneEl && cloneEl.parentNode.removeChild(cloneEl);
            if (dragEl.nextSibling !== nextEl) {
              // Get the index of the dragged element within its parent
              newIndex = _index(dragEl, options.draggable);
              if (newIndex >= 0) {
                // drag & drop within the same list
                _dispatchEvent(this, rootEl, 'update', dragEl, rootEl, oldIndex, newIndex);
                _dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
              }
            }
          }
          if (Sortable.active) {
            /* jshint eqnull:true */
            if (newIndex == null || newIndex === -1) {
              newIndex = oldIndex;
            }
            _dispatchEvent(this, rootEl, 'end', dragEl, rootEl, oldIndex, newIndex);

            // Save sorting
            this.save();
          }
        }
      }
      this._nulling();
    },
    _nulling: function _nulling() {
      if (Sortable.active === this) {
        rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = scrollEl = scrollParentEl = tapEvt = touchEvt = moved = newIndex = lastEl = lastCSS = activeGroup = Sortable.active = null;
      }
    },
    handleEvent: function handleEvent( /**Event*/evt) {
      var type = evt.type;
      if (type === 'dragover' || type === 'dragenter') {
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
      } else if (type === 'drop' || type === 'dragend') {
        this._onDrop(evt);
      }
    },
    /**
     * Serializes the item into an array of string.
     * @returns {String[]}
     */
    toArray: function toArray() {
      var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;
      for (; i < n; i++) {
        el = children[i];
        if (_closest(el, options.draggable, this.el)) {
          order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
        }
      }
      return order;
    },
    /**
     * Sorts the elements according to the array.
     * @param  {String[]}  order  order of the items
     */
    sort: function sort(order) {
      var items = {},
        rootEl = this.el;
      this.toArray().forEach(function (id, i) {
        var el = rootEl.children[i];
        if (_closest(el, this.options.draggable, rootEl)) {
          items[id] = el;
        }
      }, this);
      order.forEach(function (id) {
        if (items[id]) {
          rootEl.removeChild(items[id]);
          rootEl.appendChild(items[id]);
        }
      });
    },
    /**
     * Save the current sorting
     */
    save: function save() {
      var store = this.options.store;
      store && store.set(this);
    },
    /**
     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
     * @param   {HTMLElement}  el
     * @param   {String}       [selector]  default: `options.draggable`
     * @returns {HTMLElement|null}
     */
    closest: function closest(el, selector) {
      return _closest(el, selector || this.options.draggable, this.el);
    },
    /**
     * Set/get option
     * @param   {string} name
     * @param   {*}      [value]
     * @returns {*}
     */
    option: function option(name, value) {
      var options = this.options;
      if (value === void 0) {
        return options[name];
      } else {
        options[name] = value;
        if (name === 'group') {
          _prepareGroup(options);
        }
      }
    },
    /**
     * Destroy
     */
    destroy: function destroy() {
      var el = this.el;
      el[expando] = null;
      _off(el, 'mousedown', this._onTapStart);
      _off(el, 'touchstart', this._onTapStart);
      if (this.nativeDraggable) {
        _off(el, 'dragover', this);
        _off(el, 'dragenter', this);
      }

      // Remove draggable attributes
      Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
        el.removeAttribute('draggable');
      });
      touchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);
      this._onDrop();
      this.el = el = null;
    }
  };
  function _cloneHide(state) {
    if (cloneEl && cloneEl.state !== state) {
      _css(cloneEl, 'display', state ? 'none' : '');
      !state && cloneEl.state && rootEl.insertBefore(cloneEl, dragEl);
      cloneEl.state = state;
    }
  }
  function _closest( /**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx) {
    if (el) {
      ctx = ctx || document;
      do {
        if (selector === '>*' && el.parentNode === ctx || _matches(el, selector)) {
          return el;
        }
      } while (el !== ctx && (el = el.parentNode));
    }
    return null;
  }
  function _globalDragOver( /**Event*/evt) {
    if (evt.dataTransfer) {
      evt.dataTransfer.dropEffect = 'move';
    }
    evt.preventDefault();
  }
  function _on(el, event, fn) {
    el.addEventListener(event, fn, false);
  }
  function _off(el, event, fn) {
    el.removeEventListener(event, fn, false);
  }
  function _toggleClass(el, name, state) {
    if (el) {
      if (el.classList) {
        el.classList[state ? 'add' : 'remove'](name);
      } else {
        var className = (' ' + el.className + ' ').replace(RSPACE, ' ').replace(' ' + name + ' ', ' ');
        el.className = (className + (state ? ' ' + name : '')).replace(RSPACE, ' ');
      }
    }
  }
  function _css(el, prop, val) {
    var style = el && el.style;
    if (style) {
      if (val === void 0) {
        if (document.defaultView && document.defaultView.getComputedStyle) {
          val = document.defaultView.getComputedStyle(el, '');
        } else if (el.currentStyle) {
          val = el.currentStyle;
        }
        return prop === void 0 ? val : val[prop];
      } else {
        if (!(prop in style)) {
          prop = '-webkit-' + prop;
        }
        style[prop] = val + (typeof val === 'string' ? '' : 'px');
      }
    }
  }
  function _find(ctx, tagName, iterator) {
    if (ctx) {
      var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;
      if (iterator) {
        for (; i < n; i++) {
          iterator(list[i], i);
        }
      }
      return list;
    }
    return [];
  }
  function _dispatchEvent(sortable, rootEl, name, targetEl, fromEl, startIndex, newIndex) {
    var evt = document.createEvent('Event'),
      options = (sortable || rootEl[expando]).options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
    evt.initEvent(name, true, true);
    evt.to = rootEl;
    evt.from = fromEl || rootEl;
    evt.item = targetEl || rootEl;
    evt.clone = cloneEl;
    evt.oldIndex = startIndex;
    evt.newIndex = newIndex;
    rootEl.dispatchEvent(evt);
    if (options[onName]) {
      options[onName].call(sortable, evt);
    }
  }
  function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect) {
    var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal;
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
    evt.to = toEl;
    evt.from = fromEl;
    evt.dragged = dragEl;
    evt.draggedRect = dragRect;
    evt.related = targetEl || toEl;
    evt.relatedRect = targetRect || toEl.getBoundingClientRect();
    fromEl.dispatchEvent(evt);
    if (onMoveFn) {
      retVal = onMoveFn.call(sortable, evt);
    }
    return retVal;
  }
  function _disableDraggable(el) {
    el.draggable = false;
  }
  function _unsilent() {
    _silent = false;
  }

  /** @returns {HTMLElement|false} */
  function _ghostIsLast(el, evt) {
    var lastEl = el.lastElementChild,
      rect = lastEl.getBoundingClientRect();
    return (evt.clientY - (rect.top + rect.height) > 5 || evt.clientX - (rect.right + rect.width) > 5) && lastEl; // min delta
  }

  /**
   * Generate id
   * @param   {HTMLElement} el
   * @returns {String}
   * @private
   */
  function _generateId(el) {
    var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;
    while (i--) {
      sum += str.charCodeAt(i);
    }
    return sum.toString(36);
  }

  /**
   * Returns the index of an element within its parent for a selected set of
   * elements
   * @param  {HTMLElement} el
   * @param  {selector} selector
   * @return {number}
   */
  function _index(el, selector) {
    var index = 0;
    if (!el || !el.parentNode) {
      return -1;
    }
    while (el && (el = el.previousElementSibling)) {
      if (el.nodeName.toUpperCase() !== 'TEMPLATE' && _matches(el, selector)) {
        index++;
      }
    }
    return index;
  }
  function _matches( /**HTMLElement*/el, /**String*/selector) {
    if (el) {
      selector = selector.split('.');
      var tag = selector.shift().toUpperCase(),
        re = new RegExp('\\s(' + selector.join('|') + ')(?=\\s)', 'g');
      return (tag === '' || el.nodeName.toUpperCase() == tag) && (!selector.length || ((' ' + el.className + ' ').match(re) || []).length == selector.length);
    }
    return false;
  }
  function _throttle(callback, ms) {
    var args, _this;
    return function () {
      if (args === void 0) {
        args = arguments;
        _this = this;
        setTimeout(function () {
          if (args.length === 1) {
            callback.call(_this, args[0]);
          } else {
            callback.apply(_this, args);
          }
          args = void 0;
        }, ms);
      }
    };
  }
  function _extend(dst, src) {
    if (dst && src) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          dst[key] = src[key];
        }
      }
    }
    return dst;
  }

  // Export utils
  Sortable.utils = {
    on: _on,
    off: _off,
    css: _css,
    find: _find,
    is: function is(el, selector) {
      return !!_closest(el, selector, el);
    },
    extend: _extend,
    throttle: _throttle,
    closest: _closest,
    toggleClass: _toggleClass,
    index: _index
  };

  /**
   * Create sortable instance
   * @param {HTMLElement}  el
   * @param {Object}      [options]
   */
  Sortable.create = function (el, options) {
    return new Sortable(el, options);
  };

  // Export
  Sortable.version = '1.4.2';
  return Sortable;
});
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["callback"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function confirmDialog(_ref) {
  var callback = _ref.callback,
    options = _objectWithoutProperties(_ref, _excluded);
  var defaultOptions = $('#confirmRemoveModalMetadata').data();
  var _$$extend = $.extend({}, defaultOptions, options),
    title = _$$extend.title,
    message = _$$extend.message,
    okText = _$$extend.okText,
    cancelText = _$$extend.cancelText,
    okClass = _$$extend.okClass,
    cancelClass = _$$extend.cancelClass;
  $('<div id="confirmRemoveModal" class="modal" tabindex="-1" role="dialog">\
        <div class="modal-dialog modal-dialog-centered" role="document">\
            <div class="modal-content">\
                <div class="modal-header">\
                    <h5 class="modal-title">' + title + '</h5>\
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>\
                </div>\
                <div class="modal-body">\
                    <p>' + message + '</p>\
                </div>\
                <div class="modal-footer">\
                    <button id="modalOkButton" type="button" class="btn ' + okClass + '">' + okText + '</button>\
                    <button id="modalCancelButton" type="button" class="btn ' + cancelClass + '" data-bs-dismiss="modal">' + cancelText + '</button>\
                </div>\
            </div>\
        </div>\
    </div>').appendTo('body');
  var confirmModal = new bootstrap.Modal($('#confirmRemoveModal'), {
    backdrop: 'static',
    keyboard: false
  });
  confirmModal.show();
  document.getElementById('confirmRemoveModal').addEventListener('hidden.bs.modal', function () {
    document.getElementById('confirmRemoveModal').remove();
    confirmModal.dispose();
  });
  $('#modalOkButton').click(function () {
    callback(true);
    confirmModal.hide();
  });
  $('#modalCancelButton').click(function () {
    callback(false);
    confirmModal.hide();
  });
}
(function () {
  // Prevents page flickering while downloading css
  document.addEventListener('DOMContentLoaded', function () {
    document.body.classList.remove('preload');
  });
})();
$(function () {
  $('body').on('click', '[data-url-af~="RemoveUrl"], a[itemprop~="RemoveUrl"]', function () {
    var _this = $(this);
    if (_this.filter('a[itemprop~="UnsafeUrl"]').length == 1) {
      console.warn('Please use data-url-af instead of itemprop attribute for confirm modals. Using itemprop will eventually become deprecated.');
    }
    // don't show the confirm dialog if the link is also UnsafeUrl, as it will already be handled below.
    if (_this.filter('[data-url-af~="UnsafeUrl"], a[itemprop~="UnsafeUrl"]').length == 1) {
      return false;
    }
    confirmDialog(_objectSpread(_objectSpread({}, _this.data()), {}, {
      callback: function callback(resp) {
        if (resp) {
          var url = _this.attr('href');
          if (url == undefined) {
            var form = _this.parents('form');
            // This line is reuired in case we used the FormValueRequiredAttribute
            form.append($('<input type="hidden" name="' + _this.attr('name') + '" value="' + _this.attr('value') + '" />'));
            form.submit();
          } else {
            window.location = url;
          }
        }
      }
    }));
    return false;
  });
});
$(function () {
  var magicToken = $('input[name=__RequestVerificationToken]').first();
  if (magicToken) {
    $('body').on('click', 'a[data-url-af~="UnsafeUrl"], a[itemprop~="UnsafeUrl"]', function () {
      var _this = $(this);
      if (_this.filter('a[itemprop~="UnsafeUrl"]').length == 1) {
        console.warn('Please use data-url-af instead of itemprop attribute for confirm modals. Using itemprop will eventually become deprecated.');
      }
      var hrefParts = _this.attr("href").split("?");
      var form = $('<form action="' + hrefParts[0] + '" method="POST" />');
      form.append(magicToken.clone());
      if (hrefParts.length > 1) {
        var queryParts = hrefParts[1].split('&');
        for (var i = 0; i < queryParts.length; i++) {
          var queryPartKVP = queryParts[i].split('=');
          //trusting hrefs in the page here
          form.append($('<input type="hidden" name="' + decodeURIComponent(queryPartKVP[0]) + '" value="' + decodeURIComponent(queryPartKVP[1]) + '" />'));
        }
      }
      form.css({
        'position': 'absolute',
        'left': '-9999em'
      });
      $("body").append(form);
      var unsafeUrlPrompt = _this.data('unsafe-url');
      if (unsafeUrlPrompt && unsafeUrlPrompt.length > 0) {
        confirmDialog(_objectSpread(_objectSpread({}, _this.data()), {}, {
          callback: function callback(resp) {
            if (resp) {
              form.submit();
            }
          }
        }));
        return false;
      }
      if (_this.filter('[data-url-af~="RemoveUrl"], a[itemprop~="RemoveUrl"]').length == 1) {
        confirmDialog(_objectSpread(_objectSpread({}, _this.data()), {}, {
          callback: function callback(resp) {
            if (resp) {
              form.submit();
            }
          }
        }));
        return false;
      }
      form.submit();
      return false;
    });
  }
});
(function () {
  // Tooltips
  var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
  var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
    return new bootstrap.Tooltip(tooltipTriggerEl);
  });
})();
function getTechnicalName(name) {
  var result = '',
    c;
  if (!name || name.length == 0) {
    return '';
  }
  name = removeDiacritics(name);
  for (i = 0; i < name.length; i++) {
    c = name[i];
    if (isLetter(c) || isNumber(c) && i > 0) {
      result += c;
    }
  }
  return result;
}
function isLetter(str) {
  return str.length === 1 && str.match(/[a-z]/i);
}
function isNumber(str) {
  return str.length === 1 && str.match(/[0-9]/i);
}

//Prevent multi submissions on forms
$('body').on('submit', 'form.no-multisubmit', function (e) {
  var submittingClass = 'submitting';
  form = $(this);
  if (form.hasClass(submittingClass)) {
    e.preventDefault();
    return;
  }
  form.addClass(submittingClass);

  // safety-nest in case the form didn't refresh the page
  setTimeout(function () {
    form.removeClass(submittingClass);
  }, 5000);
});
// When we load compact status from preferences we need to do some other tasks besides adding the class to the body.
// UserPreferencesLoader has already added the needed class.
$(function () {
  // We set leftbar to compact if :
  // 1. That preference was stored by the user the last time he was on the page
  // 2. Or it's the first time on page and page is small.
  //
  if ($('body').hasClass('left-sidebar-compact') || $('body').hasClass('no-admin-preferences') && $(window).width() < 768) {
    setCompactStatus();
  }
});
$('span.title').each(function () {
  $(this).prev('.icon').prop('title', $(this).text());
});
$('.leftbar-compactor').click(function () {
  $('body').hasClass('left-sidebar-compact') ? unSetCompactStatus() : setCompactStatus(true);
});
$('#left-nav li.has-items').click(function () {
  $('#left-nav li.has-items').removeClass("visible");
  $(this).addClass("visible");
});
$(document).on("click", function (event) {
  var $trigger = $("#left-nav li.has-items");
  if ($trigger !== event.target && !$trigger.has(event.target).length) {
    $('#left-nav li.has-items').removeClass("visible");
  }
});
var subMenuArray = new Array();
function setCompactStatus(explicit) {
  // This if is to avoid that when sliding from expanded to compact the 
  // underliyng ul is visible while shrinking. It is ugly.    
  if (!$('body').hasClass('left-sidebar-compact')) {
    var labels = $('#left-nav ul.menu-admin > li > figure > figcaption > .item-label');
    labels.css('background-color', 'transparent');
    setTimeout(function () {
      labels.css('background-color', '');
    }, 200);
  }
  $('body').addClass('left-sidebar-compact');

  // When leftbar is expanded  all ul tags are collapsed.
  // When leftbar is compacted we don't want the first level collapsed. 
  // We want it expanded so that hovering over the root buttons shows the full submenu
  $('#left-nav ul.menu-admin > li > figure > ul').removeClass('collapse');
  // When hovering, don't want toggling when clicking on label
  $('#left-nav ul.menu-admin > li > figure > figcaption > a').attr('data-bs-toggle', '');
  $('#left-nav li.has-items').removeClass("visible");

  //after menu has collapsed we set the transitions to none so that we don't do any transition
  //animation when open a sub-menu
  setTimeout(function () {
    $('#left-nav > ul > li').css("transition", "none");
  }, 200);
  if (explicit == true) {
    isCompactExplicit = true;
  }
  persistAdminPreferences();
}
function unSetCompactStatus() {
  $('body').removeClass('left-sidebar-compact');

  // resetting what we disabled for compact state
  $('#left-nav ul.menu-admin > li > figure > ul').addClass('collapse');
  $('#left-nav ul.menu-admin > li > figure > figcaption a').attr('data-bs-toggle', 'collapse');
  $('#left-nav li.has-items').removeClass("visible");
  $('#left-nav > ul > li').css("transition", "");
  isCompactExplicit = false;
  persistAdminPreferences();
}
var leftNav = document.getElementById("left-nav");

// create an Observer instance
var resizeObserver = new ResizeObserver(function (entries) {
  if (isCompactExplicit) {
    if (leftNav.scrollHeight > leftNav.clientHeight) {
      document.body.classList.add("scroll");
    } else {
      document.body.classList.remove("scroll");
    }
  } else {
    document.body.classList.remove("scroll");
  }
});

// start observing a DOM node
if (leftNav != null) {
  resizeObserver.observe(leftNav);
}
/*
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
var defaultDiacriticsRemovalMap = [{
  'base': 'A',
  'letters': "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
}, {
  'base': 'AA',
  'letters': "\uA732"
}, {
  'base': 'AE',
  'letters': "\xC6\u01FC\u01E2"
}, {
  'base': 'AO',
  'letters': "\uA734"
}, {
  'base': 'AU',
  'letters': "\uA736"
}, {
  'base': 'AV',
  'letters': "\uA738\uA73A"
}, {
  'base': 'AY',
  'letters': "\uA73C"
}, {
  'base': 'B',
  'letters': "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181"
}, {
  'base': 'C',
  'letters': "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E"
}, {
  'base': 'D',
  'letters': "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779"
}, {
  'base': 'DZ',
  'letters': "\u01F1\u01C4"
}, {
  'base': 'Dz',
  'letters': "\u01F2\u01C5"
}, {
  'base': 'E',
  'letters': "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E"
}, {
  'base': 'F',
  'letters': "F\u24BB\uFF26\u1E1E\u0191\uA77B"
}, {
  'base': 'G',
  'letters': "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E"
}, {
  'base': 'H',
  'letters': "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
}, {
  'base': 'I',
  'letters': "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
}, {
  'base': 'J',
  'letters': "J\u24BF\uFF2A\u0134\u0248"
}, {
  'base': 'K',
  'letters': "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
}, {
  'base': 'L',
  'letters': "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
}, {
  'base': 'LJ',
  'letters': "\u01C7"
}, {
  'base': 'Lj',
  'letters': "\u01C8"
}, {
  'base': 'M',
  'letters': "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C"
}, {
  'base': 'N',
  'letters': "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4"
}, {
  'base': 'NJ',
  'letters': "\u01CA"
}, {
  'base': 'Nj',
  'letters': "\u01CB"
}, {
  'base': 'O',
  'letters': "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
}, {
  'base': 'OI',
  'letters': "\u01A2"
}, {
  'base': 'OO',
  'letters': "\uA74E"
}, {
  'base': 'OU',
  'letters': "\u0222"
}, {
  'base': 'OE',
  'letters': "\x8C\u0152"
}, {
  'base': 'oe',
  'letters': "\x9C\u0153"
}, {
  'base': 'P',
  'letters': "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
}, {
  'base': 'Q',
  'letters': "Q\u24C6\uFF31\uA756\uA758\u024A"
}, {
  'base': 'R',
  'letters': "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
}, {
  'base': 'S',
  'letters': "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
}, {
  'base': 'T',
  'letters': "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
}, {
  'base': 'TZ',
  'letters': "\uA728"
}, {
  'base': 'U',
  'letters': "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
}, {
  'base': 'V',
  'letters': "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245"
}, {
  'base': 'VY',
  'letters': "\uA760"
}, {
  'base': 'W',
  'letters': "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
}, {
  'base': 'X',
  'letters': "X\u24CD\uFF38\u1E8A\u1E8C"
}, {
  'base': 'Y',
  'letters': "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
}, {
  'base': 'Z',
  'letters': "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
}, {
  'base': 'a',
  'letters': "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250"
}, {
  'base': 'aa',
  'letters': "\uA733"
}, {
  'base': 'ae',
  'letters': "\xE6\u01FD\u01E3"
}, {
  'base': 'ao',
  'letters': "\uA735"
}, {
  'base': 'au',
  'letters': "\uA737"
}, {
  'base': 'av',
  'letters': "\uA739\uA73B"
}, {
  'base': 'ay',
  'letters': "\uA73D"
}, {
  'base': 'b',
  'letters': "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253"
}, {
  'base': 'c',
  'letters': "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
}, {
  'base': 'd',
  'letters': "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A"
}, {
  'base': 'dz',
  'letters': "\u01F3\u01C6"
}, {
  'base': 'e',
  'letters': "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD"
}, {
  'base': 'f',
  'letters': "f\u24D5\uFF46\u1E1F\u0192\uA77C"
}, {
  'base': 'g',
  'letters': "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F"
}, {
  'base': 'h',
  'letters': "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
}, {
  'base': 'hv',
  'letters': "\u0195"
}, {
  'base': 'i',
  'letters': "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
}, {
  'base': 'j',
  'letters': "j\u24D9\uFF4A\u0135\u01F0\u0249"
}, {
  'base': 'k',
  'letters': "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
}, {
  'base': 'l',
  'letters': "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747"
}, {
  'base': 'lj',
  'letters': "\u01C9"
}, {
  'base': 'm',
  'letters': "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F"
}, {
  'base': 'n',
  'letters': "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5"
}, {
  'base': 'nj',
  'letters': "\u01CC"
}, {
  'base': 'o',
  'letters': "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275"
}, {
  'base': 'oi',
  'letters': "\u01A3"
}, {
  'base': 'ou',
  'letters': "\u0223"
}, {
  'base': 'oo',
  'letters': "\uA74F"
}, {
  'base': 'p',
  'letters': "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755"
}, {
  'base': 'q',
  'letters': "q\u24E0\uFF51\u024B\uA757\uA759"
}, {
  'base': 'r',
  'letters': "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
}, {
  'base': 's',
  'letters': "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B"
}, {
  'base': 't',
  'letters': "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
}, {
  'base': 'tz',
  'letters': "\uA729"
}, {
  'base': 'u',
  'letters': "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
}, {
  'base': 'v',
  'letters': "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C"
}, {
  'base': 'vy',
  'letters': "\uA761"
}, {
  'base': 'w',
  'letters': "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
}, {
  'base': 'x',
  'letters': "x\u24E7\uFF58\u1E8B\u1E8D"
}, {
  'base': 'y',
  'letters': "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
}, {
  'base': 'z',
  'letters': "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
}];
var diacriticsMap = {};
for (var i = 0; i < defaultDiacriticsRemovalMap.length; i++) {
  var letters = defaultDiacriticsRemovalMap[i].letters;
  for (var j = 0; j < letters.length; j++) {
    diacriticsMap[letters[j]] = defaultDiacriticsRemovalMap[i].base;
  }
}
function removeDiacritics(str) {
  return str.replace(/[^\u0000-\u007E]/g, function (a) {
    return diacriticsMap[a] || a;
  });
}
// System to detect when the window's size reaches a given breakpoint
// Right now it is only used to compact the lefbar when resizing under 768px
// In the future maybe this is useful to do other things on resizing.

(function () {
  var breakPoint = 768;
  var lastDirection = '';
  var lastDirectionManaged = '';
  var breakpointChangeManaged = false;
  var lastWidth = document.body.clientWidth;
  window.addEventListener('resize', function () {
    var width = document.body.clientWidth;
    var direction = width < lastWidth ? 'reducing' : 'increasing';
    if (direction !== lastDirection) {
      breakpointChangeManaged = false; // need to listen for breakpoint            
    }

    if (breakpointChangeManaged == false && direction != lastDirectionManaged) {
      if (direction == 'reducing' && width < breakPoint) {
        // breakpoint reached while going down
        setCompactStatus();
        lastDirectionManaged = direction;
        breakpointChangeManaged = true;
      }
      if (direction == 'increasing' && width > breakPoint) {
        // breakpoint reached while going up
        if (isCompactExplicit == false) {
          unSetCompactStatus();
        }
        lastDirectionManaged = direction;
        breakpointChangeManaged = true;
      }
    }
    lastDirection = direction;
    lastWidth = width;
  });
})();
// Each time the sidebar status is modified, that is persisted to localStorage.
// When the page is loaded again, userPreferencesLoader.js will read that info to 
// restore the sidebar to the previous state.
function persistAdminPreferences() {
  setTimeout(function () {
    var adminPreferences = {};
    adminPreferences.leftSidebarCompact = document.body.classList.contains('left-sidebar-compact') ? true : false;
    adminPreferences.isCompactExplicit = isCompactExplicit;
    setAdminPreferences(adminPreferences);
  }, 200);
}